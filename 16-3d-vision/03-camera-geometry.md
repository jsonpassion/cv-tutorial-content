# ì¹´ë©”ë¼ ê¸°í•˜í•™

> ë‚´ë¶€/ì™¸ë¶€ íŒŒë¼ë¯¸í„°, ì—í”¼í´ë¼ ê¸°í•˜

## ê°œìš”

[í¬ì¸íŠ¸ í´ë¼ìš°ë“œ](./02-point-clouds.md)ì—ì„œ 3D ì ë“¤ì„ ì§ì ‘ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì„ ë°°ì› ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì‹¤ì œë¡œ 3D ì •ë³´ë¥¼ ì–»ìœ¼ë ¤ë©´ **ì¹´ë©”ë¼ê°€ 3D ì„¸ê³„ë¥¼ 2D ì´ë¯¸ì§€ë¡œ ë³€í™˜í•˜ëŠ” ì›ë¦¬**ë¥¼ ì´í•´í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ì„¹ì…˜ì—ì„œëŠ” **í•€í™€ ì¹´ë©”ë¼ ëª¨ë¸**, **ë‚´ë¶€/ì™¸ë¶€ íŒŒë¼ë¯¸í„°**, ê·¸ë¦¬ê³  ë‘ ì¹´ë©”ë¼ ì‚¬ì´ì˜ ê¸°í•˜í•™ì  ê´€ê³„ì¸ **ì—í”¼í´ë¼ ê¸°í•˜í•™**ì„ ë°°ì›ë‹ˆë‹¤. ì´ ì§€ì‹ì€ 3D ë³µì›, SLAM, ARì˜ ìˆ˜í•™ì  ê¸°ì´ˆì…ë‹ˆë‹¤.

**ì„ ìˆ˜ ì§€ì‹**: [ê¹Šì´ ì¶”ì •](./01-depth-estimation.md), ê¸°ì´ˆ ì„ í˜•ëŒ€ìˆ˜
**í•™ìŠµ ëª©í‘œ**:
- í•€í™€ ì¹´ë©”ë¼ ëª¨ë¸ê³¼ íˆ¬ì˜ ë°©ì •ì‹ì„ ì´í•´í•œë‹¤
- ë‚´ë¶€ íŒŒë¼ë¯¸í„°(K)ì™€ ì™¸ë¶€ íŒŒë¼ë¯¸í„°(R, t)ì˜ ì—­í• ì„ íŒŒì•…í•œë‹¤
- ì—í”¼í´ë¼ ê¸°í•˜í•™ê³¼ ê¸°ë³¸ í–‰ë ¬(F), ë³¸ì§ˆ í–‰ë ¬(E)ì„ ì´í•´í•œë‹¤
- OpenCVë¡œ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤

## ì™œ ì•Œì•„ì•¼ í• ê¹Œ?

AR ì•±ì´ ì±…ìƒ ìœ„ì— ê°€ìƒ ì»µì„ ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì— ë Œë”ë§í•˜ë ¤ë©´, ì¹´ë©”ë¼ì˜ ìœ„ì¹˜ì™€ ë°©í–¥ì„ ì •í™•íˆ ì•Œì•„ì•¼ í•©ë‹ˆë‹¤. ììœ¨ì£¼í–‰ì°¨ê°€ ìŠ¤í…Œë ˆì˜¤ ì¹´ë©”ë¼ë¡œ ê±°ë¦¬ë¥¼ ì¸¡ì •í•˜ë ¤ë©´, ë‘ ì¹´ë©”ë¼ì˜ ê¸°í•˜í•™ì  ê´€ê³„ë¥¼ ì•Œì•„ì•¼ í•©ë‹ˆë‹¤. Structure from Motionìœ¼ë¡œ ì‚¬ì§„ì—ì„œ 3D ëª¨ë¸ì„ ë§Œë“¤ë ¤ë©´, ê° ì‚¬ì§„ì´ ì–´ë””ì„œ ì°í˜”ëŠ”ì§€ ê³„ì‚°í•´ì•¼ í•©ë‹ˆë‹¤. **ì¹´ë©”ë¼ ê¸°í•˜í•™**ì€ ì´ ëª¨ë“  ê²ƒì˜ ìˆ˜í•™ì  ê¸°ë°˜ì…ë‹ˆë‹¤.

## í•µì‹¬ ê°œë…

### ê°œë… 1: í•€í™€ ì¹´ë©”ë¼ ëª¨ë¸

> ğŸ’¡ **ë¹„ìœ **: í•€í™€ ì¹´ë©”ë¼ëŠ” **ì–´ë‘ìš´ ë°©ì— ì‘ì€ êµ¬ë©ì„ ëš«ì€ ê²ƒ**ì…ë‹ˆë‹¤. êµ¬ë©ì„ í†µê³¼í•œ ë¹›ì´ ë°˜ëŒ€í¸ ë²½ì— ê±°ê¾¸ë¡œ ëœ ìƒì„ ë§ºì£ . ì¹´ë©”ë¼ ë Œì¦ˆë„ ë³¸ì§ˆì ìœ¼ë¡œ ê°™ì€ ì›ë¦¬ì´ë©°, ìˆ˜í•™ì ìœ¼ë¡œ ë‹¨ìˆœí™”í•˜ë©´ í•€í™€ ëª¨ë¸ì´ ë©ë‹ˆë‹¤.

**3D â†’ 2D íˆ¬ì˜:**

3D ê³µê°„ì˜ ì  $P = (X, Y, Z)$ê°€ ì´ë¯¸ì§€ í‰ë©´ì˜ ì  $p = (u, v)$ë¡œ íˆ¬ì˜ë˜ëŠ” ê³¼ì •:

> **íˆ¬ì˜ ê³µì‹** (ì´ìƒì  í•€í™€):
>
> $u = f \cdot \frac{X}{Z}, \quad v = f \cdot \frac{Y}{Z}$
>
> - $f$: ì´ˆì  ê±°ë¦¬ (focal length)
> - $Z$: ê¹Šì´ (ì¹´ë©”ë¼ë¡œë¶€í„°ì˜ ê±°ë¦¬)

**ì¢Œí‘œê³„ ì •ë¦¬:**

| ì¢Œí‘œê³„ | ì„¤ëª… | ë‹¨ìœ„ |
|--------|------|------|
| **ì›”ë“œ ì¢Œí‘œê³„** | ì‹¤ì œ 3D ê³µê°„ | ë¯¸í„° |
| **ì¹´ë©”ë¼ ì¢Œí‘œê³„** | ì¹´ë©”ë¼ ì¤‘ì‹¬ ê¸°ì¤€ | ë¯¸í„° |
| **ì´ë¯¸ì§€ ì¢Œí‘œê³„** | ì´ë¯¸ì§€ í‰ë©´ (ì—°ì†) | ë¯¸í„° |
| **í”½ì…€ ì¢Œí‘œê³„** | ë””ì§€í„¸ ì´ë¯¸ì§€ | í”½ì…€ |

### ê°œë… 2: ë‚´ë¶€ íŒŒë¼ë¯¸í„° (Intrinsic Parameters)

> ğŸ’¡ **ë¹„ìœ **: ë‚´ë¶€ íŒŒë¼ë¯¸í„°ëŠ” **ì¹´ë©”ë¼ì˜ "ëˆˆ" íŠ¹ì„±**ì…ë‹ˆë‹¤. ë Œì¦ˆì˜ ì´ˆì  ê±°ë¦¬, ì„¼ì„œì˜ ì¤‘ì‹¬ ìœ„ì¹˜ ë“± ì¹´ë©”ë¼ ìì²´ì˜ ê³ ìœ í•œ ì„±ì§ˆì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ê°™ì€ ì¹´ë©”ë¼ëŠ” ì–´ë””ì„œ ì°ë“  ë‚´ë¶€ íŒŒë¼ë¯¸í„°ê°€ ê°™ìŠµë‹ˆë‹¤.

**ë‚´ë¶€ í–‰ë ¬ K (Camera Matrix):**

$$K = \begin{bmatrix} f_x & s & c_x \\ 0 & f_y & c_y \\ 0 & 0 & 1 \end{bmatrix}$$

| íŒŒë¼ë¯¸í„° | ì„¤ëª… |
|----------|------|
| $f_x, f_y$ | ì´ˆì  ê±°ë¦¬ (í”½ì…€ ë‹¨ìœ„) |
| $c_x, c_y$ | ì£¼ì  (Principal Point) - ì´ë¯¸ì§€ ì¤‘ì‹¬ |
| $s$ | ë¹„ëŒ€ì¹­ ê³„ìˆ˜ (Skew) - ë³´í†µ 0 |

**ì™œ $f_x \neq f_y$ì¼ ìˆ˜ ìˆë‚˜ìš”?**

ì„¼ì„œì˜ í”½ì…€ì´ ì •ì‚¬ê°í˜•ì´ ì•„ë‹ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë˜í•œ ë Œì¦ˆ ì™œê³¡ì´ë‚˜ ì œì¡° ì˜¤ì°¨ë¡œ ê°€ë¡œ/ì„¸ë¡œ ë°°ìœ¨ì´ ë‹¤ë¥¼ ìˆ˜ ìˆì£ .

**ì™œê³¡ ê³„ìˆ˜ (Distortion Coefficients):**

ì‹¤ì œ ë Œì¦ˆëŠ” ì´ìƒì ì´ì§€ ì•Šì•„ì„œ **ì™œê³¡**ì´ ë°œìƒí•©ë‹ˆë‹¤:

| ì¢…ë¥˜ | ì„¤ëª… | íš¨ê³¼ |
|------|------|------|
| **ë°©ì‚¬ ì™œê³¡** | ë Œì¦ˆ ì¤‘ì‹¬ì—ì„œì˜ ê±°ë¦¬ì— ë”°ë¥¸ ì™œê³¡ | ë°°ëŸ´/í•€ì¿ ì…˜ |
| **ì ‘ì„  ì™œê³¡** | ë Œì¦ˆê°€ ì„¼ì„œì™€ í‰í–‰í•˜ì§€ ì•ŠìŒ | ê¸°ìš¸ì–´ì§„ ìƒ |

> **ì™œê³¡ ëª¨ë¸**:
>
> $k_1, k_2, k_3$: ë°©ì‚¬ ì™œê³¡ ê³„ìˆ˜
> $p_1, p_2$: ì ‘ì„  ì™œê³¡ ê³„ìˆ˜

### ê°œë… 3: ì™¸ë¶€ íŒŒë¼ë¯¸í„° (Extrinsic Parameters)

> ğŸ’¡ **ë¹„ìœ **: ì™¸ë¶€ íŒŒë¼ë¯¸í„°ëŠ” **ì¹´ë©”ë¼ê°€ ì„¸ìƒ ì–´ë””ì—, ì–´ëŠ ë°©í–¥ì„ ë³´ê³  ìˆëŠ”ì§€**ì…ë‹ˆë‹¤. ê°™ì€ ì¹´ë©”ë¼ë„ ìœ„ì¹˜ì™€ ë°©í–¥ì„ ë°”ê¾¸ë©´ ì™¸ë¶€ íŒŒë¼ë¯¸í„°ê°€ ë‹¬ë¼ì§‘ë‹ˆë‹¤. ë§ˆì¹˜ "ëˆˆì˜ ìœ„ì¹˜ì™€ ì‹œì„  ë°©í–¥"ê³¼ ê°™ì£ .

**ì™¸ë¶€ íŒŒë¼ë¯¸í„°:**

| íŒŒë¼ë¯¸í„° | ì°¨ì› | ì„¤ëª… |
|----------|------|------|
| **íšŒì „ (R)** | 3Ã—3 | ì›”ë“œ â†’ ì¹´ë©”ë¼ ì¢Œí‘œ íšŒì „ |
| **ì´ë™ (t)** | 3Ã—1 | ì›”ë“œ â†’ ì¹´ë©”ë¼ ì¢Œí‘œ ì´ë™ |

**ë³€í™˜ ë°©ì •ì‹:**

$$P_{camera} = R \cdot P_{world} + t$$

**ë™ì°¨ ì¢Œí‘œë¡œ í‘œí˜„:**

$$\begin{bmatrix} u \\ v \\ 1 \end{bmatrix} = K \begin{bmatrix} R | t \end{bmatrix} \begin{bmatrix} X \\ Y \\ Z \\ 1 \end{bmatrix}$$

**íˆ¬ì˜ í–‰ë ¬ P:**

$$P = K [R | t]$$

3Ã—4 í–‰ë ¬ë¡œ, 3D ì ì„ 2D ì´ë¯¸ì§€ ì¢Œí‘œë¡œ ì§ì ‘ ë³€í™˜í•©ë‹ˆë‹¤.

### ê°œë… 4: ì—í”¼í´ë¼ ê¸°í•˜í•™

> ğŸ’¡ **ë¹„ìœ **: ë‘ ëˆˆìœ¼ë¡œ ë¬¼ì²´ë¥¼ ë³¼ ë•Œ, ì™¼ìª½ ëˆˆì—ì„œ ë³´ì´ëŠ” ì ì´ ì˜¤ë¥¸ìª½ ëˆˆì—ì„œëŠ” **íŠ¹ì • ì„  ìœ„**ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ë§ˆì¹˜ ë¹›ì´ ì™¼ìª½ ëˆˆì„ í†µê³¼í•˜ëŠ” ê´‘ì„ ì´ ì˜¤ë¥¸ìª½ ëˆˆì—ì„œ ì„ ìœ¼ë¡œ ë³´ì´ëŠ” ê²ƒì²˜ëŸ¼ìš”. ì´ê²Œ **ì—í”¼í´ë¼ ì„ **ì…ë‹ˆë‹¤.

**í•µì‹¬ ìš”ì†Œ:**

| ìš©ì–´ | ì„¤ëª… |
|------|------|
| **ì—í”¼í´ (Epipole)** | ë‹¤ë¥¸ ì¹´ë©”ë¼ì˜ ì¤‘ì‹¬ì´ ì´ë¯¸ì§€ì— íˆ¬ì˜ëœ ì  |
| **ì—í”¼í´ë¼ ì„  (Epipolar Line)** | í•œ ì´ë¯¸ì§€ì˜ ì ì— ëŒ€ì‘í•˜ëŠ” ë‹¤ë¥¸ ì´ë¯¸ì§€ì˜ ì„  |
| **ì—í”¼í´ë¼ í‰ë©´** | 3D ì ê³¼ ë‘ ì¹´ë©”ë¼ ì¤‘ì‹¬ì„ í¬í•¨í•˜ëŠ” í‰ë©´ |

**ì—í”¼í´ë¼ ì œì•½:**

> ì™¼ìª½ ì´ë¯¸ì§€ì˜ ì  $x$ì— ëŒ€ì‘í•˜ëŠ” ì˜¤ë¥¸ìª½ ì´ë¯¸ì§€ì˜ ì  $x'$ëŠ” ë°˜ë“œì‹œ **ì—í”¼í´ë¼ ì„  ìœ„**ì— ìˆìŠµë‹ˆë‹¤.

ì´ ì œì•½ ë•ë¶„ì— ìŠ¤í…Œë ˆì˜¤ ë§¤ì¹­ì—ì„œ **2D ê²€ìƒ‰ì„ 1D ê²€ìƒ‰**ìœ¼ë¡œ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤!

### ê°œë… 5: ê¸°ë³¸ í–‰ë ¬ (Fundamental Matrix)ê³¼ ë³¸ì§ˆ í–‰ë ¬ (Essential Matrix)

**ê¸°ë³¸ í–‰ë ¬ F:**

> ğŸ’¡ **ë¹„ìœ **: ê¸°ë³¸ í–‰ë ¬ì€ **ë‘ ì´ë¯¸ì§€ ì‚¬ì´ì˜ ë²ˆì—­ê¸°**ì…ë‹ˆë‹¤. í•œ ì´ë¯¸ì§€ì˜ ì ì„ ë„£ìœ¼ë©´, ë‹¤ë¥¸ ì´ë¯¸ì§€ì—ì„œ ê·¸ ì ì´ ìˆì–´ì•¼ í•  **ì—í”¼í´ë¼ ì„ **ì„ ì•Œë ¤ì¤ë‹ˆë‹¤.

$$x'^T F x = 0$$

- $x$: ì²« ë²ˆì§¸ ì´ë¯¸ì§€ì˜ ì  (ë™ì°¨ ì¢Œí‘œ)
- $x'$: ë‘ ë²ˆì§¸ ì´ë¯¸ì§€ì˜ ëŒ€ì‘ì 
- $F$: 3Ã—3 ê¸°ë³¸ í–‰ë ¬ (rank 2)

**ê¸°ë³¸ í–‰ë ¬ì˜ íŠ¹ì„±:**

| íŠ¹ì„± | ì„¤ëª… |
|------|------|
| **í¬ê¸°** | 3Ã—3 |
| **ë­í¬** | 2 (íŠ¹ì´ê°’ í•˜ë‚˜ê°€ 0) |
| **ììœ ë„** | 7 (ìŠ¤ì¼€ì¼ ì œì™¸ 8ê°œ íŒŒë¼ë¯¸í„°, det=0 ì œì•½ -1) |
| **ì¶”ì •** | ìµœì†Œ 7~8 ëŒ€ì‘ì  í•„ìš” |

**ì—í”¼í´ë¼ ì„  ê³„ì‚°:**

- ì˜¤ë¥¸ìª½ ì´ë¯¸ì§€ì˜ ì—í”¼í´ë¼ ì„ : $l' = Fx$
- ì™¼ìª½ ì´ë¯¸ì§€ì˜ ì—í”¼í´ë¼ ì„ : $l = F^T x'$

**ë³¸ì§ˆ í–‰ë ¬ E:**

ë³¸ì§ˆ í–‰ë ¬ì€ **ìº˜ë¦¬ë¸Œë ˆì´ì…˜ëœ ì¢Œí‘œ**ì—ì„œì˜ ê¸°ë³¸ í–‰ë ¬ì…ë‹ˆë‹¤:

$$E = K'^T F K$$

$$\hat{x}'^T E \hat{x} = 0$$

- $\hat{x} = K^{-1}x$: ì •ê·œí™”ëœ ì¹´ë©”ë¼ ì¢Œí‘œ

**ë³¸ì§ˆ í–‰ë ¬ê³¼ ì™¸ë¶€ íŒŒë¼ë¯¸í„°:**

$$E = [t]_\times R$$

- $[t]_\times$: ì´ë™ ë²¡í„°ì˜ ë°˜ëŒ€ì¹­ í–‰ë ¬ (Skew-symmetric)
- $R$: íšŒì „ í–‰ë ¬

SVDë¡œ $E$ë¥¼ ë¶„í•´í•˜ë©´ $R$ê³¼ $t$ë¥¼ ë³µì›í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!

## ì‹¤ìŠµ: ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜

### ì²´ìŠ¤ë³´ë“œë¥¼ ì´ìš©í•œ ìº˜ë¦¬ë¸Œë ˆì´ì…˜

```python
import cv2
import numpy as np
import glob

def calibrate_camera(image_folder, pattern_size=(9, 6), square_size=0.025):
    """
    ì²´ìŠ¤ë³´ë“œ íŒ¨í„´ìœ¼ë¡œ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜

    Args:
        image_folder: ì²´ìŠ¤ë³´ë“œ ì´ë¯¸ì§€ í´ë” ê²½ë¡œ
        pattern_size: ë‚´ë¶€ ì½”ë„ˆ ê°œìˆ˜ (ê°€ë¡œ, ì„¸ë¡œ)
        square_size: ì •ì‚¬ê°í˜• í•œ ë³€ í¬ê¸° (ë¯¸í„°)

    Returns:
        ret: ì¬íˆ¬ì˜ ì˜¤ì°¨
        K: ë‚´ë¶€ í–‰ë ¬
        dist: ì™œê³¡ ê³„ìˆ˜
        rvecs, tvecs: ê° ì´ë¯¸ì§€ì˜ íšŒì „/ì´ë™ ë²¡í„°
    """
    # 3D ì  ì¢Œí‘œ (ì²´ìŠ¤ë³´ë“œ í‰ë©´, Z=0)
    objp = np.zeros((pattern_size[0] * pattern_size[1], 3), np.float32)
    objp[:, :2] = np.mgrid[0:pattern_size[0], 0:pattern_size[1]].T.reshape(-1, 2)
    objp *= square_size

    # ì  ì €ì¥ ë¦¬ìŠ¤íŠ¸
    obj_points = []  # 3D ì 
    img_points = []  # 2D ì 

    # ì´ë¯¸ì§€ ë¡œë“œ ë° ì½”ë„ˆ ê²€ì¶œ
    images = glob.glob(f"{image_folder}/*.jpg")
    print(f"ë°œê²¬ëœ ì´ë¯¸ì§€: {len(images)}ê°œ")

    for fname in images:
        img = cv2.imread(fname)
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        # ì²´ìŠ¤ë³´ë“œ ì½”ë„ˆ ì°¾ê¸°
        ret, corners = cv2.findChessboardCorners(gray, pattern_size, None)

        if ret:
            obj_points.append(objp)

            # ì„œë¸Œí”½ì…€ ì •í™•ë„ë¡œ ì½”ë„ˆ ì •ì œ
            criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
            corners_refined = cv2.cornerSubPix(gray, corners, (11, 11), (-1, -1), criteria)
            img_points.append(corners_refined)

            # ì‹œê°í™” (ì„ íƒ)
            cv2.drawChessboardCorners(img, pattern_size, corners_refined, ret)
            cv2.imshow('Corners', img)
            cv2.waitKey(100)

    cv2.destroyAllWindows()

    # ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ìˆ˜í–‰
    ret, K, dist, rvecs, tvecs = cv2.calibrateCamera(
        obj_points, img_points, gray.shape[::-1], None, None
    )

    print(f"\nìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ!")
    print(f"ì¬íˆ¬ì˜ ì˜¤ì°¨: {ret:.4f} í”½ì…€")
    print(f"\në‚´ë¶€ í–‰ë ¬ K:\n{K}")
    print(f"\nì™œê³¡ ê³„ìˆ˜: {dist.ravel()}")

    return ret, K, dist, rvecs, tvecs


def undistort_image(img, K, dist):
    """ì™œê³¡ ë³´ì •"""
    h, w = img.shape[:2]

    # ìµœì ì˜ ìƒˆ ì¹´ë©”ë¼ í–‰ë ¬ ê³„ì‚°
    new_K, roi = cv2.getOptimalNewCameraMatrix(K, dist, (w, h), 1, (w, h))

    # ì™œê³¡ ë³´ì •
    undistorted = cv2.undistort(img, K, dist, None, new_K)

    # ROIë¡œ ìë¥´ê¸°
    x, y, w, h = roi
    undistorted = undistorted[y:y+h, x:x+w]

    return undistorted


# ì‚¬ìš© ì˜ˆì‹œ
if __name__ == "__main__":
    # ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ìˆ˜í–‰
    ret, K, dist, rvecs, tvecs = calibrate_camera(
        "calibration_images/",
        pattern_size=(9, 6),
        square_size=0.025  # 2.5cm
    )

    # ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê²°ê³¼ ì €ì¥
    np.savez("camera_calibration.npz", K=K, dist=dist)

    # ìƒˆ ì´ë¯¸ì§€ ì™œê³¡ ë³´ì •
    test_img = cv2.imread("test.jpg")
    undistorted = undistort_image(test_img, K, dist)

    cv2.imwrite("undistorted.jpg", undistorted)
```

### ê¸°ë³¸ í–‰ë ¬ê³¼ ì—í”¼í´ë¼ ì„  ê³„ì‚°

```python
import cv2
import numpy as np
import matplotlib.pyplot as plt

def compute_fundamental_matrix(pts1, pts2, method=cv2.FM_RANSAC):
    """
    ëŒ€ì‘ì ìœ¼ë¡œ ê¸°ë³¸ í–‰ë ¬ ê³„ì‚°

    Args:
        pts1: ì²« ë²ˆì§¸ ì´ë¯¸ì§€ì˜ ì ë“¤ (N, 2)
        pts2: ë‘ ë²ˆì§¸ ì´ë¯¸ì§€ì˜ ì ë“¤ (N, 2)

    Returns:
        F: ê¸°ë³¸ í–‰ë ¬ (3, 3)
        mask: ì¸ë¼ì´ì–´ ë§ˆìŠ¤í¬
    """
    pts1 = pts1.astype(np.float32)
    pts2 = pts2.astype(np.float32)

    F, mask = cv2.findFundamentalMat(pts1, pts2, method, ransacReprojThreshold=3.0)

    print(f"ê¸°ë³¸ í–‰ë ¬ F:\n{F}")
    print(f"ì¸ë¼ì´ì–´: {mask.sum()}/{len(mask)}")

    return F, mask


def draw_epipolar_lines(img1, img2, pts1, pts2, F):
    """
    ì—í”¼í´ë¼ ì„  ì‹œê°í™”

    Args:
        img1, img2: ë‘ ì´ë¯¸ì§€
        pts1, pts2: ëŒ€ì‘ì 
        F: ê¸°ë³¸ í–‰ë ¬
    """
    def draw_lines(img, lines, pts):
        """ì´ë¯¸ì§€ì— ì—í”¼í´ë¼ ì„  ê·¸ë¦¬ê¸°"""
        h, w = img.shape[:2]
        img_color = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)

        for line, pt in zip(lines, pts):
            color = tuple(np.random.randint(0, 255, 3).tolist())

            # ì„  ì‹œì‘/ëì  ê³„ì‚°
            a, b, c = line
            x0, y0 = 0, int(-c / b)
            x1, y1 = w, int(-(c + a * w) / b)

            cv2.line(img_color, (x0, y0), (x1, y1), color, 1)
            cv2.circle(img_color, tuple(pt.astype(int)), 5, color, -1)

        return img_color

    # ì˜¤ë¥¸ìª½ ì´ë¯¸ì§€ì˜ ì—í”¼í´ë¼ ì„  (Fx)
    lines2 = cv2.computeCorrespondEpilines(pts1.reshape(-1, 1, 2), 1, F)
    lines2 = lines2.reshape(-1, 3)
    img2_lines = draw_lines(img2, lines2, pts2)

    # ì™¼ìª½ ì´ë¯¸ì§€ì˜ ì—í”¼í´ë¼ ì„  (F^T x')
    lines1 = cv2.computeCorrespondEpilines(pts2.reshape(-1, 1, 2), 2, F)
    lines1 = lines1.reshape(-1, 3)
    img1_lines = draw_lines(img1, lines1, pts1)

    # ì‹œê°í™”
    fig, axes = plt.subplots(1, 2, figsize=(14, 7))
    axes[0].imshow(img1_lines)
    axes[0].set_title("ì´ë¯¸ì§€ 1 + ì—í”¼í´ë¼ ì„ ")
    axes[0].axis("off")

    axes[1].imshow(img2_lines)
    axes[1].set_title("ì´ë¯¸ì§€ 2 + ì—í”¼í´ë¼ ì„ ")
    axes[1].axis("off")

    plt.tight_layout()
    plt.savefig("epipolar_lines.png")
    plt.show()


def compute_essential_matrix(F, K1, K2):
    """
    ê¸°ë³¸ í–‰ë ¬ì—ì„œ ë³¸ì§ˆ í–‰ë ¬ ê³„ì‚°

    E = K2^T * F * K1
    """
    E = K2.T @ F @ K1
    return E


def decompose_essential_matrix(E, K, pts1, pts2):
    """
    ë³¸ì§ˆ í–‰ë ¬ì—ì„œ R, t ë³µì›

    Args:
        E: ë³¸ì§ˆ í–‰ë ¬
        K: ì¹´ë©”ë¼ ë‚´ë¶€ í–‰ë ¬
        pts1, pts2: ëŒ€ì‘ì 

    Returns:
        R: íšŒì „ í–‰ë ¬
        t: ì´ë™ ë²¡í„°
    """
    # OpenCVì˜ recoverPose ì‚¬ìš©
    _, R, t, mask = cv2.recoverPose(E, pts1, pts2, K)

    print(f"íšŒì „ í–‰ë ¬ R:\n{R}")
    print(f"ì´ë™ ë²¡í„° t:\n{t.flatten()}")

    return R, t


# ì‚¬ìš© ì˜ˆì‹œ
if __name__ == "__main__":
    # ë‘ ì´ë¯¸ì§€ ë¡œë“œ
    img1 = cv2.imread("view1.jpg", cv2.IMREAD_GRAYSCALE)
    img2 = cv2.imread("view2.jpg", cv2.IMREAD_GRAYSCALE)

    # íŠ¹ì§•ì  ë§¤ì¹­ (SIFT)
    sift = cv2.SIFT_create()
    kp1, desc1 = sift.detectAndCompute(img1, None)
    kp2, desc2 = sift.detectAndCompute(img2, None)

    # BF ë§¤ì¹­
    bf = cv2.BFMatcher()
    matches = bf.knnMatch(desc1, desc2, k=2)

    # ì¢‹ì€ ë§¤ì¹­ í•„í„°ë§ (Lowe's ratio test)
    good_matches = []
    for m, n in matches:
        if m.distance < 0.7 * n.distance:
            good_matches.append(m)

    print(f"ì¢‹ì€ ë§¤ì¹­: {len(good_matches)}")

    # ëŒ€ì‘ì  ì¶”ì¶œ
    pts1 = np.float32([kp1[m.queryIdx].pt for m in good_matches])
    pts2 = np.float32([kp2[m.trainIdx].pt for m in good_matches])

    # ê¸°ë³¸ í–‰ë ¬ ê³„ì‚°
    F, mask = compute_fundamental_matrix(pts1, pts2)

    # ì¸ë¼ì´ì–´ë§Œ ì‚¬ìš©
    pts1_inlier = pts1[mask.ravel() == 1]
    pts2_inlier = pts2[mask.ravel() == 1]

    # ì—í”¼í´ë¼ ì„  ì‹œê°í™”
    draw_epipolar_lines(img1, img2, pts1_inlier[:20], pts2_inlier[:20], F)

    # ì¹´ë©”ë¼ í–‰ë ¬ì´ ìˆë‹¤ë©´ ë³¸ì§ˆ í–‰ë ¬ ê³„ì‚°
    K = np.array([[800, 0, 320], [0, 800, 240], [0, 0, 1]], dtype=np.float32)
    E = compute_essential_matrix(F, K, K)

    # R, t ë³µì›
    R, t = decompose_essential_matrix(E, K, pts1_inlier, pts2_inlier)
```

### 3D ì  ì‚¼ê°í™”

```python
import cv2
import numpy as np

def triangulate_points(K, R1, t1, R2, t2, pts1, pts2):
    """
    ë‘ ë·°ì—ì„œ 3D ì  ì‚¼ê°í™”

    Args:
        K: ì¹´ë©”ë¼ ë‚´ë¶€ í–‰ë ¬
        R1, t1: ì²« ë²ˆì§¸ ì¹´ë©”ë¼ ì™¸ë¶€ íŒŒë¼ë¯¸í„°
        R2, t2: ë‘ ë²ˆì§¸ ì¹´ë©”ë¼ ì™¸ë¶€ íŒŒë¼ë¯¸í„°
        pts1, pts2: ëŒ€ì‘ì  (N, 2)

    Returns:
        points_3d: ì‚¼ê°í™”ëœ 3D ì  (N, 3)
    """
    # íˆ¬ì˜ í–‰ë ¬ ê³„ì‚°
    P1 = K @ np.hstack([R1, t1])
    P2 = K @ np.hstack([R2, t2])

    # ì‚¼ê°í™”
    pts1_h = pts1.T  # (2, N)
    pts2_h = pts2.T

    points_4d = cv2.triangulatePoints(P1, P2, pts1_h, pts2_h)

    # ë™ì°¨ ì¢Œí‘œ â†’ 3D ì¢Œí‘œ
    points_3d = points_4d[:3] / points_4d[3]
    points_3d = points_3d.T  # (N, 3)

    return points_3d


# ì‚¬ìš© ì˜ˆì‹œ
if __name__ == "__main__":
    # ì¹´ë©”ë¼ 1: ì›ì 
    R1 = np.eye(3)
    t1 = np.zeros((3, 1))

    # ì¹´ë©”ë¼ 2: x ë°©í–¥ìœ¼ë¡œ 0.5m ì´ë™, ì•½ê°„ íšŒì „
    R2 = cv2.Rodrigues(np.array([0, 0.1, 0]))[0]  # yì¶• íšŒì „
    t2 = np.array([[0.5], [0], [0]])

    # ì˜ˆì‹œ ëŒ€ì‘ì 
    K = np.array([[800, 0, 320], [0, 800, 240], [0, 0, 1]], dtype=np.float32)
    pts1 = np.array([[100, 150], [200, 180], [300, 200]], dtype=np.float32)
    pts2 = np.array([[80, 150], [180, 180], [280, 200]], dtype=np.float32)

    # ì‚¼ê°í™”
    points_3d = triangulate_points(K, R1, t1, R2, t2, pts1, pts2)
    print(f"3D ì :\n{points_3d}")
```

## ë” ê¹Šì´ ì•Œì•„ë³´ê¸°: ë©€í‹°ë·° ê¸°í•˜í•™ì˜ ì—­ì‚¬

**1980ë…„ëŒ€ â€” ì—í”¼í´ë¼ ê¸°í•˜í•™ì˜ ì •ë¦½**

ì»´í“¨í„° ë¹„ì „ì˜ ì´ˆê¸°ì— Longuet-Higgins(1981)ê°€ **ë³¸ì§ˆ í–‰ë ¬(Essential Matrix)**ì„ ë„ì…í–ˆìŠµë‹ˆë‹¤. ë‘ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ëœ ì¹´ë©”ë¼ ì‚¬ì´ì˜ ê´€ê³„ë¥¼ 8ê°œ ëŒ€ì‘ì ìœ¼ë¡œ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ë³´ì˜€ì£ .

**1992ë…„ â€” ê¸°ë³¸ í–‰ë ¬ê³¼ ì‹¤ìš©í™”**

Hartleyì™€ Zissermanì˜ ì—°êµ¬ë¡œ **ê¸°ë³¸ í–‰ë ¬(Fundamental Matrix)**ì´ ì •ë¦½ë˜ì—ˆìŠµë‹ˆë‹¤. ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì—†ì´ë„ ë‘ ì´ë¯¸ì§€ ì‚¬ì´ì˜ ê¸°í•˜í•™ì  ê´€ê³„ë¥¼ ì•Œ ìˆ˜ ìˆê²Œ ë˜ì—ˆì£ . ì´ ì—°êµ¬ëŠ” "Multiple View Geometry in Computer Vision" ì±…ìœ¼ë¡œ ì§‘ëŒ€ì„±ë˜ì–´, 3D ë¹„ì „ì˜ êµê³¼ì„œê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.

**2000ë…„ëŒ€ â€” RANSACê³¼ ê°•ê±´í•œ ì¶”ì •**

ì‹¤ì œ ë°ì´í„°ì—ëŠ” ë…¸ì´ì¦ˆì™€ ì•„ì›ƒë¼ì´ì–´ê°€ ìˆìŠµë‹ˆë‹¤. Fischlerì™€ Bollesì˜ **RANSAC**(Random Sample Consensus)ì´ í‘œì¤€ ë°©ë²•ì´ ë˜ì–´, ì˜ëª»ëœ ëŒ€ì‘ì ì´ ìˆì–´ë„ ì•ˆì •ì ìœ¼ë¡œ í–‰ë ¬ì„ ì¶”ì •í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

**2010ë…„ëŒ€ ì´í›„ â€” ë”¥ëŸ¬ë‹ê³¼ì˜ ë§Œë‚¨**

SuperPoint, SuperGlue ê°™ì€ ë”¥ëŸ¬ë‹ ê¸°ë°˜ íŠ¹ì§• ë§¤ì¹­ì´ ë“±ì¥í•˜ë©´ì„œ, ë” ì •í™•í•œ ëŒ€ì‘ì ì„ ì–»ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ê¸°í•˜í•™ì  ê´€ê³„ë¥¼ ê³„ì‚°í•˜ëŠ” ê³¼ì •ì€ ì—¬ì „íˆ ì „í†µì ì¸ ë°©ë²•ì´ ì‚¬ìš©ë©ë‹ˆë‹¤.

## í”í•œ ì˜¤í•´ì™€ íŒ

> âš ï¸ **í”í•œ ì˜¤í•´**: "ê¸°ë³¸ í–‰ë ¬ê³¼ ë³¸ì§ˆ í–‰ë ¬ì€ ê°™ë‹¤"
>
> ë‹¤ë¦…ë‹ˆë‹¤. **ë³¸ì§ˆ í–‰ë ¬(E)**ì€ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ëœ ì •ê·œí™” ì¢Œí‘œì—ì„œ ì •ì˜ë˜ê³ , **ê¸°ë³¸ í–‰ë ¬(F)**ì€ í”½ì…€ ì¢Œí‘œì—ì„œ ì •ì˜ë©ë‹ˆë‹¤. ê´€ê³„ëŠ” $E = K'^T F K$ì…ë‹ˆë‹¤.

> ğŸ’¡ **ì•Œê³  ê³„ì…¨ë‚˜ìš”?**: ì—í”¼í´ë¼ ì œì•½ì€ **ìŠ¤í…Œë ˆì˜¤ ë§¤ì¹­ì˜ í•µì‹¬**ì…ë‹ˆë‹¤. ì „ì²´ ì´ë¯¸ì§€ì—ì„œ ëŒ€ì‘ì ì„ ì°¾ëŠ” ëŒ€ì‹ , ì—í”¼í´ë¼ ì„  ìœ„ì—ì„œë§Œ ì°¾ìœ¼ë©´ ë©ë‹ˆë‹¤. ê²€ìƒ‰ ê³µê°„ì´ O(nÂ²)ì—ì„œ O(n)ìœ¼ë¡œ ì¤„ì–´ë“œëŠ” ê±°ì£ !

> ğŸ”¥ **ì‹¤ë¬´ íŒ**: ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í’ˆì§ˆì€ **ì²´ìŠ¤ë³´ë“œ ì´ë¯¸ì§€ ìˆ˜ì™€ ë‹¤ì–‘ì„±**ì— ë‹¬ë ¤ìˆìŠµë‹ˆë‹¤. ìµœì†Œ 15~20ì¥, ë‹¤ì–‘í•œ ê°ë„ì™€ ìœ„ì¹˜ì—ì„œ ì´¬ì˜í•˜ì„¸ìš”. ì½”ë„ˆê°€ ì´ë¯¸ì§€ ê°€ì¥ìë¦¬ê¹Œì§€ ë¶„í¬í•˜ë©´ ë” ì¢‹ìŠµë‹ˆë‹¤.

> ğŸ”¥ **ì‹¤ë¬´ íŒ**: ê¸°ë³¸ í–‰ë ¬ ì¶”ì •ì—ì„œ **RANSAC**ì„ ë°˜ë“œì‹œ ì‚¬ìš©í•˜ì„¸ìš”. íŠ¹ì§• ë§¤ì¹­ì—ëŠ” í•­ìƒ ì˜ëª»ëœ ëŒ€ì‘ì (ì•„ì›ƒë¼ì´ì–´)ì´ ìˆê³ , ì´ê²ƒë“¤ì´ ê²°ê³¼ë¥¼ í¬ê²Œ ì™œê³¡í•©ë‹ˆë‹¤.

## í•µì‹¬ ì •ë¦¬

| ê°œë… | ì„¤ëª… |
|------|------|
| **ë‚´ë¶€ íŒŒë¼ë¯¸í„° K** | ì´ˆì  ê±°ë¦¬, ì£¼ì  ë“± ì¹´ë©”ë¼ ê³ ìœ  íŠ¹ì„± |
| **ì™¸ë¶€ íŒŒë¼ë¯¸í„° R, t** | ì›”ë“œì—ì„œ ì¹´ë©”ë¼ë¡œì˜ ë³€í™˜ (ìœ„ì¹˜, ë°©í–¥) |
| **íˆ¬ì˜ í–‰ë ¬ P** | P = K[R\|t], 3Dâ†’2D ì§ì ‘ ë³€í™˜ |
| **ì—í”¼í´ë¼ ì„ ** | í•œ ì´ë¯¸ì§€ ì ì— ëŒ€ì‘í•˜ëŠ” ë‹¤ë¥¸ ì´ë¯¸ì§€ì˜ ì„  |
| **ê¸°ë³¸ í–‰ë ¬ F** | í”½ì…€ ì¢Œí‘œ ê¸°ë°˜, ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë¶ˆí•„ìš” |
| **ë³¸ì§ˆ í–‰ë ¬ E** | ì •ê·œí™” ì¢Œí‘œ ê¸°ë°˜, R/t ë³µì› ê°€ëŠ¥ |

## ë‹¤ìŒ ì„¹ì…˜ ë¯¸ë¦¬ë³´ê¸°

ì¹´ë©”ë¼ ê¸°í•˜í•™ì˜ ìˆ˜í•™ì  ê¸°ì´ˆë¥¼ ë‹¤ì¡ŒìŠµë‹ˆë‹¤. ë‹¤ìŒ ì„¹ì…˜ [SLAM ê¸°ì´ˆ](./04-slam.md)ì—ì„œëŠ” ì´ ì§€ì‹ì„ í™œìš©í•´ **ë¡œë´‡ì´ ì´ë™í•˜ë©´ì„œ ë™ì‹œì— ì§€ë„ë¥¼ ë§Œë“œëŠ” SLAM(Simultaneous Localization and Mapping)**ì„ ë°°ì›ë‹ˆë‹¤. ì¹´ë©”ë¼ê°€ ì›€ì§ì´ë©´ì„œ ìê¸° ìœ„ì¹˜ë¥¼ ì¶”ì •í•˜ê³ , í™˜ê²½ì˜ 3D êµ¬ì¡°ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³µì›í•˜ëŠ” ê¸°ìˆ ì´ì£ !

## ì°¸ê³  ìë£Œ

- [Multiple View Geometry in Computer Vision](https://www.robots.ox.ac.uk/~vgg/hzbook/) - Hartley & Zissermanì˜ êµê³¼ì„œ
- [ì—í”¼í´ë¼ ê¸°í•˜í•™ í•´ì„¤](https://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/OWENS/LECT10/node3.html) - ì—ë“ ë²„ëŸ¬ ëŒ€í•™
- [OpenCV ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜](https://docs.opencv.org/4.x/dc/dbb/tutorial_py_calibration.html) - ê³µì‹ íŠœí† ë¦¬ì–¼
- [Fundamental Matrix í•´ì„¤](https://en.wikipedia.org/wiki/Fundamental_matrix_(computer_vision)) - Wikipedia
- [ì—í”¼í´ë¼ ê¸°í•˜í•™ Medium](https://medium.com/@sarcas0705/computer-vision-epipolar-geometry-36b032d697a3) - ì‹œê°ì  ì„¤ëª…
